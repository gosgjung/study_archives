# 엔티티매핑 4종류

JPA에서 엔티티 매핑을 하는 방식은 아래와 같이 크게 네 가지의 관계로 나뉘어 진다.

- 1:N 관계
- N:1 관계
- 1:1 관계
- N:M 관계



# 1. 연관관계 매핑시 고려사항

엔티티의 연관관계를 매핑할 때 주요하게 고민하는 사항들은 아래와 같이 크게 3가지이다.

- 매핑관계
  - @ManyToOne
  - @OneToMany
  - @OneToOne
  - @ManyToMany (거의 쓰이지 않는 편)
- 단방향 vs 양방향
- 연관관계의 주인을 어디에 둘 것인지



# 2. 단방향 ? 양방향?

## 테이블의 관점

- FK로 양쪽 테이블을 조인 가능하다.
- 방향 개념이 없다. (논리적인 의미의 방향 개념을 둘 필요가 없다)

  

## 객체 지향식 관점

- 참조용 필드가 있는 쪽으로만 참조 가능
- 단방향 참조, 양방향 참조 두 가지 중 한가지 방식으로 참조 관계를 지정한다.
- 주 테이블은 보통 상대편 테이블의 PK를 FK로 가진다.

  

# 3. 연관관계의 주인

- 서로 다른 두 테이블을 조인 할 때 FK로 두 테이블이 연관관계를 맺는다.
- 객체 양방향 관계는 A->B, B->A로 각각 관계를 맺는 방식 (따라서 참조점이 2군데)
- 두 테이블 중 FK를 관리할 테이블을 지정해주어야 한다. 
- **연관관계의 주인** 
  - **대상(Target)테이블의 PK를 FK로 가지고 있는 참조**
  - 객체 매핑시에 연관관계의 주인을 정해주어야 한다. (단순 쿼리시에는 이러한 것이 별 필요가 없긴 하다.)
  - **@JoinColumn 이 있는 클래스가 연관관계의 주인**이다.
- **주인의 반대편**
  - 외래 키에 영향을 주지 않는다.
  - 단순 조회만 가능하다.
  - **@XtoX(mappedBy= "") 을 두는 곳이 주인의 상대편**이다.
    - 매핑당하는 입장이고 읽기 전용 필드이다.



# 4. 다대일 ? 일대다? 두개를 어떻게 구분해?

- 1:N 관계
  - @OneToMany 인 곳에서 @JoinColumn을 통해 관계를 맺는다.
- N:1 관계
  - @ManyToOne 인 곳에서 @JoinColumn을 통해 관계를 맺는다.
- 1:1 관계
  - 추후 정리 예정 !TODO
- N:M 관계
  - 추후 정리 예정 !TODO



# 5. 1:N 관계 (Employee, Department)

## 테이블 

Employee, Department 테이블이 있다고 해보자. 관계는 아래와 같다.

![이미지](./img/1-N-ERD-EMPLOYEE-DEPARTMENT.png)



## 객체 관계 표현

> 1:N 관계는 항상 항상 N (다)쪽에 외래키가 있다.  
>
> 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조를 가지고 있다.
>
> **@OneToMany 인 쪽에서 @JoinColumn을 통해 관계를 맺는다.**

### 단방향

- 권장되는 방식은 아니다.  
  - 1:N(일대다) 단방향 매핑보다는 N:1 (다대일) 단방향을 사용하다가 필요시에 양방향으로 추가해주는 방식으로 하는 것이 더 권장된다.

- **@JoinColumn** 을 사용해 자기 자신의 테이블내에서 상대 테이블이 조인할 컬럼을 지정해준다. (이 컬럼으로 조인하세요. 라는 의미)   
- @JoinColumn 을 사용하지 않으면 중간에 매핑테이블이 하나 더 생긴다. (JoinTable 방식을 사용하게 된다. JPA가 테이블을 하나 더 추가해주는 것)

- Department 안에는 List \<Employee> employees 가 있다. 하지만, Employee 에서는 Department 를 신경쓰고 싶지 않을 경우 사용(아래 코드에서 보다시피 Employee 내부에는 어떠한 mappedBy 등의 코드가 없다.)  
- 단점으로는 insert 하고나서 update 쿼리도 나간다는 점이다. 운영상에서도 성능상에 이슈를 낼 수 있다는 점이 단점이다. 또한 실무에서 관리하게 되는 테이블의 갯수만 해도 엄청나게 많기 때문에 이런 경우는 관리가 힘들어진다.
- 분명 나는 Department에 손을 댔는데, 왜 Employee 테이블에 update쿼리가 나가지? 하는 의문점이 생기기 쉽다. 



![이미지](./img/1-N-ORM-EXAMPLE-1.png)

![이미지](./img/1-N-ORM-EXAMPLE-2.png)



#### Employee.java

```java
@Builder
@Getter @Setter
@Entity(name = "EMPLOYEE")
public class Employee {

	@Id @GeneratedValue
	@Column(name = "EMP_NO")
	private Long id;

	@Column(name = "USERNAME")
	private String username;

	@Column(name = "SALARY")
	private Double salary;

}
```



#### Departmemt.java

```java
@Builder
@Getter @Setter
@Entity(name = "DEPARTMENT")
public class Department {

	@Id @GeneratedValue
	@Column(name = "DEPT_NO")
	private Long deptNo;

	@Column(name = "DEPT_NAME")
	private String deptName;

	@OneToMany
	@JoinColumn(name = "DEPT_NO")
	private List<Employee> employees = new ArrayList<>();

}
```



#### 테스트 코드

```java
@SpringBootTest
@Transactional
@Commit
public class MappingTest {

	@Autowired
	private EntityManager em;

	@Test
	void testInsertEmployees(){
		System.out.println("======= Employee 객체 생성 =======");
		Employee e1 = Employee.builder()
			.username("경찰관#1")
			.salary(1000D)
			.build();

		System.out.println("======= em.persist(e1) =======");
		em.persist(e1);

		System.out.println("======= Department 객체 생성 =======");

		Department d1 = Department.builder()
			.deptName("소하1동경찰서")
			.employees(new ArrayList<>())
			.build();							// DEPARTMENT 테이블에 INSERT 하면 되는 내용이다.

		System.out.println("======= Department.employees.add(e1) =======");
		d1.getEmployees().add(e1);				// DEPARTMENT 테이블에 INSERT 될수 있는 내용은 아니다.
												// DEPARTMENT 테이블이 아니라 EMPLOYEE 테이블을 UPDATE 하게 된다.

		System.out.println("======= em.persist(d1) =======");
		em.persist(d1);
	}

	@AfterEach
	void close(){
		em.close();
	}
}
```



#### 출력결과

```
... 중략 ...
======= Employee 객체 생성 =======
======= em.persist(e1) =======
2020-09-05 15:28:23.684 DEBUG 26212 --- [           main] org.hibernate.SQL                        : 
    insert 
    into
        employee
        (salary, username) 
    values
        (?, ?)
======= Department 객체 생성 =======
======= Department.employees.add(e1) =======
======= em.persist(d1) =======
2020-09-05 15:28:23.704 DEBUG 26212 --- [           main] org.hibernate.SQL                        : 
    insert 
    into
        department
        (dept_name) 
    values
        (?)
2020-09-05 15:28:23.723 DEBUG 26212 --- [           main] org.hibernate.SQL                        : 
    update
        employee 
    set
        dept_no=? 
    where
        emp_no=?
... 중략
```



> 참고)  
>
> 위의 테스트 코드에서 @Commit 을 붙이지 않거나 em.commit() 을 명시적으로 호출해주지 않으면 update 쿼리는 나가지 않는다.









