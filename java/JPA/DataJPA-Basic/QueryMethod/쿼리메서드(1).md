# 쿼리메서드 (1)

# 1. 메소드 이름으로 쿼리 생성

Spring Data JPA 를 사용하면, 메소드 이름을 분석헤서 JPQL 쿼리를 실행할 수 있다. Emp 테이블에서 이름과 부서번호로 사원을 조회하는 경우의 예제를 들어서 정리해보려고 한다.  

예제는 

- 순수JPA 사용 예제
- Spring Data JPA 를 사용 예제

의 예제를 들어서 차이점을 비교할 예정이다.  

## 순수 JPA 사용예제

### repository

```java
public List<Employee> findByUsernameAndDeptNo(String username, int deptno){
  return 
    em.createQuery("select e from Employee e where e.username = :username and e.deptno = :deptno")
    	.setParameter("username", username)
    	.setParameter("age", age)
    	.getResultList();
}
```



### test

```java
public void TestEmployeeJPA {
  // ...
  @Test
  public void findByUsernameAndDeptNo (){
    Employee e1 = new Employee("경찰관1", 112);
    Employee e2 = new Employee("소방관1", 119);
    empRepository.save(e1);
    empRepository.save(e2);
    
    List<Member> result = 
      empRepository.findByUsernameAndDeptNo("경찰관1", 112);
    assertThat(result.get(0).getUsername()).isEqualTo("경찰관1");
    assertThat(result.get(0).getDeptNo()).isEqualTo(112);
    assertThat(result.size()).isEqualTo(1);
  }
}
```



## 스프링 데이터 JPA

스프링 데이터 JPA는 메서드 이름에 명시한 필드 명과 And, Or 등을 분석해서 JPQL을 생성하고 실행한다. (내부적으로는 reflection을 사용하는 것으로 보인다.) IDE의 자동완성의 도움을 받아서 작성할 수 있다.  

  

스프링 데이터 JPA 사용시에는 인터페이스 JpaRepository\<엔티티클래스, @Id필드의 타입\>을 extends 해서 사용한다.  

### 예제

```java
public interface EmpDataRepository extends JpaRepository<Employee, Long> {
  List<Employee> findByUsernameAndDeptNo(String username, int age);
}
```

쿼리 메서드 이름을 분석해서 where 절에 조건절을 다는 필터링 방식에 대한 공식문서는 https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation 에 있으니 참고하자.  

  

### 주의

주의 해야 하는 점이 있다. 엔티티의 필드 명을 변경할 경우 리포지터리내에 해당 필드가 포함된 모든 메서드를 수정해야 한다. 수정하지 않으면 컴파일 타임에 미리 빨간 줄로 에러를 내므로, 일일이 찾아서 수정하는 것이 그리 불편한 점은 아니다. 런타임에 에러를 내지 않는다는 것만으로도 감사하다.



### 세부 쿼리

우리는 Spring Data JPA를 쓰고 있다. 하지만, SQL을 날린다는 사실에는 변함이 없다. 어떤 SQL을 날리는지 이해하고 사용해야 한다. 여기에 대한 공식문서들 및 기본적인 SQL 예약함수 들에 대한 Data JPA의 함수를 정리해보면 아래와 같다.  

- 조회
  - findXXXBy, readXXXBy, queryXXXBy, getXXXBy
  - 참고자료 - [https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation)
- COUNT
  - countXXXBy
  - 반환 타입 : long
- EXISTS
  - existsXXXBy
  - 반환 타입 : boolean
- 삭제
  - deleteXXXBy, removeXXXBy
  - 반환 타입 : long
- DISTINCT
  - findDistinct, findEmployeeDistinctBy
- LIMIT
  - findFirst3, findFirst, findTop, findTop3
  - https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.limit-query-result

# 2. JPA NamedQuery

@NamedQuery 어노테이션으로 쿼리에 이름을 부여해서 사용하는 기능이다. entity에 NamedQuery를 선언하여 이름을 붙인 쿼리를 사용할 수 있다. 또는 @NamedQuery 를 선언하는 대신 xml 문서에도 이름을 부여한 쿼리를 선언할 수도 있다.  

현업에서는 실제로 사용할 예를 찾기가 힘들다고 한다. @NamedQuery는 컴파일 타임에 쿼리의 오류를 찾을 수 있다는 장점이 있다.

## 예제 

### Employee.java

```java
@Entity
@Getter @Setter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@ToString(of={"id", "username", "age"})
@NamedQuery(
  name = "Employee.findByUsername",
  query = "select e from Employee e where e.username = :username"
)
public class Employee{
  @Id @GeneratedValue
  @Column
  private Long empId;
  private String username;
  private Long deptNo;
  
  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "deptNo")
  private Department dept;
  
  // ...
}
```

## 순수 JPA 에서 @NamedQuery 사용

### EmployeeRepository.java

```java
@Repository
public class EmployeeRepository{
  private final EntityManager em;
  
  public EmployeeRepository(EntityManager em){
    this.em = em;
  }
  
  // ...
  
  public List<Employee> findByUsername(String username){
    return 
      em.createQuery("Employee.findByUsername", Employee.class)
      	.setParameter("username", username)
      	.getResultList();
  }
}
```
위의 소스에서 Entity인 Employee 에 선언한  NamedQuery를 불러오는 부분은 아래와 같다.   
> ```java   
>   public List<Employee> findByUsername(String username){
>     return 
>       em.createQuery("Employee.findByUsername", Employee.class)
>       	.setParameter("username", username)
>       	.getResultList();
>   }
> ```
> Entity 에서 선언한 NamedQuery 를 불러올 때는 createQuery 메서드의 첫 번째 인자로 NamedQuery 명을 지정했다.

  

### 테스트 코드

```java
@SpringBootTest
@Transactional
public class EmployeeRepositoryTest{
  
  @Autowired
  EntityManager em;
  
  @Autowired
  EmployeeRepository repository;
  
  @BeforeEach
  public void before(){   
    Employee e1 = new Employee("경찰관1", 112);
    Employee e2 = new Employee("소방관1", 119);
    repository.save(e1);
    repository.save(e2);
  }
  
  // ...
  @Test
  void testNamedQuery(){
    List<Employee> result = repository.findByUsername("경찰관1");
    Member police1 = result.get(0);
    assertThat(police1.getUsername()).isEqualTo("경찰관1");
  }
  
}
```



## Data JPA 에서 @NamedQuery 사용

### EmployeeDataRepository.java

순수 JPA로 작성한 EmployeeRepository 에서 작성한 메서드와는 다르게 Data JPA 리포지터리인 EmployeeDataRepository를 사용할 경우는 구현이 단순해진다.  

> - 메서드 위에 @Query(name = "Employee.findByUsername") 를 명시한다.
> - @NamedQuery 에 파라미터가 있다면 해당 항목을 @Param("파라미터명") 으로 파라미터를 지정해준다.

을 지정해주는 것으로 간단히 해결 가능하다. 

```java
public interface EmployeeDataRepository extends JpaRepository<Employee, Long> {
  // ..
  @Query(name = "Employee.findByUsername")
  List<Emplooyee> findByUsername(@Param("username") String username);
  // ...
}
```

@Param을 꼭 지정해주어야 한다는 점에 유의하자.  

### 테스트 코드

```java
@SpringBootTest
@Transactional
public class EmployeeDataRepositoryTest{
  
  @Autowired
  EntityManager em;
  
  @Autowired
  EmployeeDataRepository repository;
  
  @BeforeEach
  public void before(){   
    Employee e1 = new Employee("경찰관1", 112);
    Employee e2 = new Employee("소방관1", 119);
    repository.save(e1);
    repository.save(e2);
  }
  
  // ...
  @Test
  void testDataJPANamedQuery(){
    List<Employee> result = repository.findByUsername("경찰관1");
    Member police1 = result.get(0);
    assertThat(police1.getUsername()).isEqualTo("경찰관1");
  }
  
}
```



# 3. @Query 어노테이션 - 리포지터리 메서드에 쿼리 정의

메서드 위에 @Query 를 선언해서 바로 jpql 문자열을 @Query 애노테이션의 인자값으로 넘겨주는 방식이다. 컴파일 타임에 쿼리의 오류를 잡아낼 수 있다는 장점이 있다.  

넘어오는 파라미터가 많아서 메서드를 일일이 

- 필드명1And필드명2And필드명3GreaterThan.... 

과 같이 입력하기 힘들어질 때가 있다.  

이런 경우에 @Query 어노테이션을 사용하면 훨씬 수월하다. 동적쿼리를 생성할 때 유용한 편이다. 가끔 쿼리가 더 복잡해지고, 조인과 성능상의 이슈로 SQL 실행계획에 맞게끔 최적화가를 해야 할 때가 있는데... 이럴 때는 querydsl, jooq 등의 라이브러리를 사용한다.  

## EmployeeDataRepository.java

```java
public interface EmployeeDataRepository extends JpaRepository<Employee, Long> {
  // ... 
  
  @Query("select e from Employee e where e.username = :username and e.deptno = :deptNo")
  List<Emplooyee> findEmployee(@Param("username") String username, @Param("deptNo") Long deptNo);

  // ...
}
```

  

## 테스트 코드

```java
@SpringBootTest
@Transactional
public class EmployeeDataRepositoryTest{
  
  @Autowired
  EntityManager em;
  
  @Autowired
  EmployeeDataRepository repository;
  
  @BeforeEach
  public void before(){   
    Employee e1 = new Employee("경찰관1", 112);
    Employee e2 = new Employee("소방관1", 119);
    repository.save(e1);
    repository.save(e2);
  }
  
  // ...
  @Test
  void testDataJPANamedQuery(){
    List<Employee> result = repository.findEmployee("경찰관1", 112);
    Member police1 = result.get(0);
    assertThat(police1.getUsername()).isEqualTo("경찰관1");
  }
  
}
```

