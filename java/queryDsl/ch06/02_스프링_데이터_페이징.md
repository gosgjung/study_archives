# 스프링 데이터 페이징 

페이징은 페이지네이션 또는 페이징 이런 용어로 업계에서 자주 통용되는 단어이다. 보통 웹 계층 관련 로직 구현 시 페이징 기능은 꼭 거쳐야 하는 과정 중 하나이다. 



# 간단한 페이징

굉장히 간단한 페이징을 작성해보자. QueryDsl에서 제공하는 기본 페이징 기능을 사용하는 형식은 아래와 같다. (페이징 기능을 최적화 없이 그대로 사용할 때의 예제)  

페이징이 적용된 queryDsl 을 사용하여 결과를 반환할 때 fetch() 메서드 대신 fetchResults()를 사용한다. fetchResults() 메서드가 리턴하는 QueryResults\<T\> 은 content, total 값을 가지고 있다. 

**fetchResults()**  

- content는  
  - 결과 값 데이터를 의미한다.
- total
  - 결과값으로 가져온 결과 데이터 리스트의 사이즈를 의미한다.

**offset, limit**  

- offset
  - 몇 번째 구간의 페이지를 보여줄지를 나타낸다. (1페이지, 2페이지 ....)
  - 0... i ... n-1의 형식이다.
- limit
  - 데이터를 몇개 단위로 묶을지를 나타낸다.
  - 만약 30을 지정했다면 30단위로 여러개의 페이지가 생성된다.



## 간단한 예제

간략한 예제를 살펴보면 아래와 같다.

**ex) searchPageSimple (MemberSearchCondition condition, Pageable pageable)**  

```java
// ...
public Page<MemberTeamDto> searchPageSimple(MemberSearchCondition condition, Pageable pageable){

  QMember member = QMember.member;
  
  QueryResults<QSomeDto> fetchResults = 
    queryFactory
      .select( new QSomeDto(....) )
      .from( QSomeType.somefield )
      .leftJoin(member.team, team)
      .where(
        ...
      )
      .limit(pageable.getPageSize())
      .offset(pageable.getOffset())
      .fetchResults();
  
  // content 를 가져온다.
  List<MemberTeamDto> content = fetchResults.getResults();
  // total (즉, count 쿼리의 결과를 가져온다.)
  long total = results.getTotal();
  
  return new PageImpl<MemberTeamDto>(results, pageable, total);
}
```

**Pageable pageable**  

- 스프링 부트에서는 Pageable을 제공한다.
- 요청에 대해 페이징과 관련된 요청은 Pageable로 분류되게 된다.

**offset, limit**  

- offset
  - 몇 번째 구간의 페이지를 보여줄지를 나타낸다. (1페이지, 2페이지 ....)
  - 0... i ... n-1의 형식이다.
- limit
  - 데이터를 몇개 단위로 묶을지를 나타낸다.
  - 만약 30을 지정했다면 30단위로 여러개의 페이지가 생성된다.

**fetchResults()**  

- fetchResults()가 반환하는 결과 타입은 QueryResults 이다.

- QueryResults는 

  - content
  - total

  값을 가지고 있다.

- QueryResults로 content와 total 을 모두 가져올 수 있다.

- fetchResults() 메서드를 사용하면 querydsl 내부적으로

  - content 쿼리
  - count 쿼리

  이렇게 두 번의 SQL 연산을 수행하게 된다.
  
- 즉, fetchResults()는 내부적으로 두번의 쿼리를 수행한다.

- querydsl로 작성된 쿼리에 orderby()가 있더라도, 카운트 쿼리시에는 무시된다.

  - 카운트 쿼리 실행시 필요없는 order by 는 제거된다.

- 카운트 쿼리는 잘못 쓰면, 실제 운영상에서 오버헤드를 야기할 수 있다. 이러한 문제로 인해 최적화하는 방법에 대해 아래의 "최적화(1)"에서 정리한다.

  

## 테스트 코드

```java
@SpringBootTest
@Transactional
class MemberJpaCustomTest{
  
  @Autowired
  EntityManager em;
  
  @Autowired
  MemberDataJpaRepository dataJpaRepository;
  
  @BeforeEach
  public void before(){
    Team marketingTeam = new Team("Marketing");
		Team analysisTeam = new Team("Analysis");
		Team musicianTeam = new Team("Musician");
		Team nullTeam = new Team("NullTeam");

		em.persist(marketingTeam);
		em.persist(analysisTeam);
		em.persist(musicianTeam);
		em.persist(nullTeam);

		Member john = new Member("John", 23, marketingTeam);
		Member susan = new Member("Becky", 22, marketingTeam);

		Member kyle = new Member("Kyle", 28, analysisTeam);
		Member stacey = new Member("Stacey", 24, analysisTeam);

		Member aladin = new Member("Aladdin", 35, analysisTeam);
		Member genie = new Member("Genie", 41, analysisTeam);

		Member beethoven = new Member("Beethoven", 251, musicianTeam);
		Member chopin = new Member("Chopin", 210, musicianTeam);
		Member genie2 = new Member("Genie", 210, musicianTeam);
		Member nullName = new Member(null, 100, musicianTeam);

		Member ceo = new Member("Jordan", 49, null);

		em.persist(john);
		em.persist(susan);
		em.persist(kyle);
		em.persist(stacey);
		em.persist(aladin);
		em.persist(genie);

		em.persist(beethoven);
		em.persist(chopin);
		em.persist(genie2);
		em.persist(nullName);
		em.persist(ceo);
  }
  
  @Test
	public void searchPageSimpleTest(){
		MemberSearchCondition condition = new MemberSearchCondition();
    
    QMember member = QMember.member;
    
		// 스프링 데이터의 페이지네이션의 page 는 0번 부터 시작된다.
		PageRequest pageRequest = PageRequest.of(0, 3);
		Page<MemberTeamDto> results = dataJpaRepository.searchPageSimple(condition, pageRequest);

		assertThat(results.getSize()).isEqualTo(3);

		assertThat(results.getContent())
			.extracting("username")
			.containsExactly("John", "Becky", "Kyle");

		System.out.println("results === ");
		System.out.println(results);
	}
}
```



- PageRequest pageRequest = PageRequest.of(0, 3)
  - 3개씩 데이터의 사이즈를 구분지어 묶었을때의 첫번째 페이지의 페이지를 의미.
  - 여기서는 테스트를 위해 PageRequest 클래스로 직접 Pageable 타입의 객체를 생성하고 있다.
  - PageRequest 클래스
    - 인터페이스 Pageable 과 호환된다.
    - PageRequest 클래스는 AbstractPageRequest 클래스를 상속한 클래스인데, AbstractPageRequest클래스는 Pageable을 implements 하고 있다.
  - PageRequest.of 
    - 첫번째 인자 
      - page 번호를 의미한다.
    - 두번째 인자
      - size 를 의미한다.
      - 즉, 몇 개의 데이터를 들고올지를 의미한다.

## 전체 코드

전체 코드를 모두 적을 필요는 없을 것 같다. 강의를 들으며 전체 코드를 작성했고, 요약 문서를 작성하면서 전체 코드를 작성하려 했는데... 이렇게 하면 너무 TMI가 되어, 설명하려는 요점을 잃는 것 같은 기분이 들었다. 여기서는 QueryDsl을 이용한 페이징 기능을 일부 구문을 예로 들어 설명하는데에만 중점을 두는 것이 나을 것 같아 생략한다. 




# 최적화 (1) - Count시 불필요한 Join제거

데이터의 내용과 카운트를 별도로 조회하도록 한다. fetchResults()를 사용하지 않고 

- 데이터의 내용 (content)
- 카운트

를 따로 fetch()를 사용하여 조회하도록 하는 경우이다. 즉, fetchResults() 없이, fetch()만을 이용해 쿼리를 수행한다.

queryDsl의 fetchResults()로도 충분히 되는 내용인데, 왜 분해해서 직접 작성하지? 할 수도 있다. 카운트 하는데에 있어서 굳이 Join을 사용하지 않고 카운트를 해야 하는 경우도 있다. 예를 들면 멤버의 수를 카운트를 할때 팀의 이름까지 출력할 필요는 없기 때문에 배제해도 된다.

**예제)** 

```java
package com.study.qdsl.repository.custom;

//...

public class MemberJpaCustomImpl implements MemberJpaCustom {

	private final EntityManager em;
	private final JPAQueryFactory queryFactory;

	public MemberJpaCustomImpl(EntityManager em){
		this.em = em;
		queryFactory = new JPAQueryFactory(em);
	}

  // ...
  
	@Override
	public Page<MemberTeamDto> searchPageComplex(MemberSearchCondition condition, Pageable pageable) {

		List<MemberTeamDto> results = queryFactory.select(
			new QMemberTeamDto(
				member.id.as("memberId"),
				member.username.as("username"),
				member.age,
				team.id.as("teamId"),
				team.name.as("teamName")
			)
		)
		.from(member)
		.leftJoin(member.team, team)
		.where(
			userNameEq(condition),
			teamNameEq(condition),
			ageGoe(condition),
			ageLoe(condition)
		)
		.offset(pageable.getOffset())
		.limit(pageable.getPageSize())
		.fetch();
    
		long count = queryFactory.select(member)
			.from(member)
//			.leftJoin(member.team, team) // 필요 없을 때도 있다.
			.where(
				userNameEq(condition),
				teamNameEq(condition),
				ageGoe(condition),
				ageLoe(condition)
			)
			.limit(pageable.getPageSize())
			.offset(pageable.getOffset())
			.fetchCount();

		return new PageImpl<MemberTeamDto>(results, pageable, count);
	}
  // ...
}
```





# 최적화 (2) - 선택적으로 count쿼리 수행

데이터의 내용을 조회해오는데, 굳이 count 쿼리를 수행하지 않아도, 가져온 데이터의 size()로 구해낼 수 있는 경우가 있다.  

count 쿼리를 생략할 수 있는 경우는 아래와 같다.

- 페이지의 시작이면서 컨텐츠 사이즈가 페이지 사이즈보다 작을때
  - ex) 페이지의 사이즈는 30개로 정했는데 DB에는 20개의 글 밖에 존재하지 않을때
- 마지막 페이지 일때
  - offset + 컨텐츠 사이즈 를 통해서 충분히 전체 사이즈를 구할 수 있다.
  - 카운트 쿼리를 할 필요가 없다.

이 경우 역시 fetchResults()를 바로 사용하지 않는다. 

- 데이터의 내용(content)
  - fetch() 로 가져온다.
- 사이즈 (totalCount)
  - fetch(), fetchCount() 하지 않은 querydsl 표현식을 가지고 있는다.
  - fetch(), fetchCount() 하지 않았을 때의 querydsl 표현식은 
    - JPAQuery\<T\> 타입의 표현식이 된다.
  - 이 JPAQuery\<T\> 표현식을 PageableExecutionUtils의 getPage() 메서드 내에 세번째 인자값으로 넘겨준다.

> ```java
> return PageableExecutionUtils.getPage(results, pageable, countSql::fetchCount);
> ```
>
> - results : 
>
>   - 데이터의 내용 (content) 을 가져온 쿼리 결과
>
> - pageage 
>
>   - 리턴값으로 돌려줄 Pageable 객체이다.
>
> - countSql::fetchCount
>
>   - countSql은 JPAQuery<T> 타입의 querydsl 표현식이다.
>
>   - PageableExecutionUtils.getPage() 내부동작은 results와 pageable을 검사하여 
>
>     - fetchCount 쿼리를 날릴지 
>     - 아니면 List<Member> 의 size()를 구하는 식으로 간결히 해결할지
>     - offset에 size()를 더하는 식으로 해결할지 결정하도록 
>
>     되어있다.



예제를 보자.

예제)  

```java
package com.study.qdsl.repository.custom;

// ...

public class MemberJpaCustomImpl implements MemberJpaCustom {

	private final EntityManager em;
	private final JPAQueryFactory queryFactory;

	public MemberJpaCustomImpl(EntityManager em){
		this.em = em;
		queryFactory = new JPAQueryFactory(em);
	}

	// ...
  
	@Override
	public Page<MemberTeamDto> searchPageOptimized(MemberSearchCondition condition, Pageable pageable) {
		List<MemberTeamDto> results = queryFactory.select(new QMemberTeamDto(
			member.id.as("memberId"),
			member.username.as("username"),
			member.age,
			member.team.id.as("teamId"),
			member.team.name.as("teamName")
		))
		.from(member)
		.leftJoin(member.team, team)
		.where(
			userNameEq(condition),
			teamNameEq(condition),
			ageGoe(condition),
			ageLoe(condition)
		)
		.offset(pageable.getOffset())
		.limit(pageable.getPageSize())
		.fetch();

		/** Query 를 람다 표현식에 저장 */
		JPAQuery<Member> countSql = queryFactory
			.select(member)
			.from(member)
			.where(
				userNameEq(condition),
				teamNameEq(condition),
				ageGoe(condition),
				ageLoe(condition)
			);

		// SQL을 람다 표현식으로 감싸서 람다 또는 메서드 레퍼린스를 인자로 전달해준다.
		// PageableExecutionUtils 에서 위의 1),2) 에 해당하면 SQL 호출을 따로 하지 않는다.
//		return PageableExecutionUtils.getPage(results, pageable, ()->countSql.fetchCount());
		// or
		return PageableExecutionUtils.getPage(results, pageable, countSql::fetchCount);
	}
}
```

