# 스프링 데이터 페이징 

페이징은 페이지네이션 또는 페이징 이런 용어로 업계에서 자주 통용되는 단어이다. 보통 웹 계층 관련 로직 구현 시 페이징 기능은 꼭 거쳐야 하는 과정 중 하나이다. 



# 간단한 페이징

굉장히 간단한 페이징을 작성해보자. QueryDsl에서 제공하는 기본 페이징 기능을 사용하는 형식은 아래와 같다. (페이징 기능을 최적화 없이 그대로 사용할 때의 예제)  

페이징이 적용된 queryDsl 을 사용하여 결과를 반환할 때 fetch() 메서드 대신 fetchResults()를 사용한다. fetchResults() 메서드가 리턴하는 QueryResults\<T\> 은 content, total 값을 가지고 있다. 

**fetchResults()**  

- content는  
  - 결과 값 데이터를 의미한다.
- total
  - 결과값으로 가져온 결과 데이터 리스트의 사이즈를 의미한다.

**offset, limit**  

- offset
  - 몇 번째 구간의 페이지를 보여줄지를 나타낸다. (1페이지, 2페이지 ....)
  - 0... i ... n-1의 형식이다.
- limit
  - 데이터를 몇개 단위로 묶을지를 나타낸다.
  - 만약 30을 지정했다면 30단위로 여러개의 페이지가 생성된다.



## 간단한 예제

간략한 예제를 살펴보면 아래와 같다.

**ex) searchPageSimple (MemberSearchCondition condition, Pageable pageable)**  

```java
// ...
public Page<MemberTeamDto> searchPageSimple(MemberSearchCondition condition, Pageable pageable){
  
  QueryResults<QSomeDto> fetchResults = 
    queryFactory
      .select( new QSomeDto(....) )
      .from( QSomeType.somefield )
      .leftJoin(member.team, team)
      .where(
        ...
      )
      .limit(pageable.getPageSize())
      .offset(pageable.getOffset())
      .fetchResults();
  
  // content 를 가져온다.
  List<MemberTeamDto> content = fetchResults.getResults();
  // total (즉, count 쿼리의 결과를 가져온다.)
  long total = results.getTotal();
  
  return new PageImpl<MemberTeamDto>(results, pageable, total);
}
```

**Pageable pageable**  

- 스프링 부트에서는 Pageable을 제공한다.
- 요청에 대해 페이징과 관련된 요청은 Pageable로 분류되게 된다.

**offset, limit**  

- offset
  - 몇 번째 구간의 페이지를 보여줄지를 나타낸다. (1페이지, 2페이지 ....)
  - 0... i ... n-1의 형식이다.
- limit
  - 데이터를 몇개 단위로 묶을지를 나타낸다.
  - 만약 30을 지정했다면 30단위로 여러개의 페이지가 생성된다.

**fetchResults()**  

- fetchResults()가 반환하는 결과 타입은 QueryResults 이다.

- QueryResults는 

  - content
  - total

  값을 가지고 있다.

- QueryResults로 content와 total 을 모두 가져올 수 있다.

- fetchResults() 메서드를 사용하면 querydsl 내부적으로

  - content 쿼리
  - count 쿼리

  이렇게 두 번의 SQL 연산을 수행하게 된다.
  
- 즉, fetchResults()는 내부적으로 두번의 쿼리를 수행한다.

- 카운트 쿼리 실행시 필요없는 order by 는 제거된다.

- 카운트 쿼리는 잘못 쓰면, 실제 운영상에서 오버헤드를 야기할 수 있다. 이러한 문제로 인해 최적화하는 방법에 대해 아래의 "최적화(1)"에서 정리한다.

  

## 테스트 코드

```java
@SpringBootTest
@Transactional
class MemberJpaCustomTest{
  
  @Autowired
  EntityManager em;
  
  @Autowired
  MemberDataJpaRepository dataJpaRepository;
  
  @BeforeEach
  public void before(){
    Team marketingTeam = new Team("Marketing");
		Team analysisTeam = new Team("Analysis");
		Team musicianTeam = new Team("Musician");
		Team nullTeam = new Team("NullTeam");

		em.persist(marketingTeam);
		em.persist(analysisTeam);
		em.persist(musicianTeam);
		em.persist(nullTeam);

		Member john = new Member("John", 23, marketingTeam);
		Member susan = new Member("Becky", 22, marketingTeam);

		Member kyle = new Member("Kyle", 28, analysisTeam);
		Member stacey = new Member("Stacey", 24, analysisTeam);

		Member aladin = new Member("Aladdin", 35, analysisTeam);
		Member genie = new Member("Genie", 41, analysisTeam);

		Member beethoven = new Member("Beethoven", 251, musicianTeam);
		Member chopin = new Member("Chopin", 210, musicianTeam);
		Member genie2 = new Member("Genie", 210, musicianTeam);
		Member nullName = new Member(null, 100, musicianTeam);

		Member ceo = new Member("Jordan", 49, null);

		em.persist(john);
		em.persist(susan);
		em.persist(kyle);
		em.persist(stacey);
		em.persist(aladin);
		em.persist(genie);

		em.persist(beethoven);
		em.persist(chopin);
		em.persist(genie2);
		em.persist(nullName);
		em.persist(ceo);
  }
  
  @Test
	public void searchPageSimpleTest(){
		MemberSearchCondition condition = new MemberSearchCondition();
		// 스프링 데이터의 페이지네이션의 page 는 0번 부터 시작된다.
		PageRequest pageRequest = PageRequest.of(0, 3);
		Page<MemberTeamDto> results = dataJpaRepository.searchPageSimple(condition, pageRequest);

		assertThat(results.getSize()).isEqualTo(3);

		assertThat(results.getContent())
			.extracting("username")
			.containsExactly("John", "Becky", "Kyle");

		System.out.println("results === ");
		System.out.println(results);
	}
}
```



- PageRequest pageRequest = PageRequest.of(0, 3)
  - 3개씩 데이터의 사이즈를 구분지어 묶었을때의 첫번째 페이지의 페이지를 의미.
  - 여기서는 테스트를 위해 PageRequest 클래스로 직접 Pageable 타입의 객체를 생성하고 있다.
  - PageRequest 클래스
    - 인터페이스 Pageable 과 호환된다.
    - PageRequest 클래스는 AbstractPageRequest 클래스를 상속한 클래스인데, AbstractPageRequest클래스는 Pageable을 implements 하고 있다.
  - PageRequest.of 
    - 첫번째 인자 
      - page 번호를 의미한다.
    - 두번째 인자
      - size 를 의미한다.
      - 즉, 몇 개의 데이터를 들고올지를 의미한다.

## 전체 코드

전체 코드를 모두 적을 필요는 없을 것 같다. 강의를 들으며 전체 코드를 작성했고, 요약 문서를 작성하면서 전체 코드를 작성하려 했는데... 이렇게 하면 너무 TMI가 되어, 설명하려는 요점을 잃는 것 같은 기분이 들었다. 여기서는 QueryDsl을 이용한 페이징 기능을 일부 구문을 예로 들어 설명하는데에만 중점을 두는 것이 나을 것 같아 생략한다. 




# 최적화 (1)

