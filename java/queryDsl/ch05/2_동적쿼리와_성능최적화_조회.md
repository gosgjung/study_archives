# 동적 쿼리와 성능최적화 조회



# 목차

- DTO 생성
- Builder 사용방식
- Where절 동적 쿼리



# DTO 생성

Projection을 이용해 DTO를 생성한다. 멤버와 멤버가 속한 팀의 id, 팀의 이름을 모두 출력하기 위해 Member, Team 엔티티의 필드들을 합친 모양의 Dto를 하나 생성했다.  

이런 DTO를 Projection으로 반영하기 위해서는 따로 Projection을 해주어야 한다. 보통 QueryDsl 의 쿼리 속에서

- Projections.bean
- Projections.fields
- Projections.constructor

을 사용하는 방법도 있지만 여기서는 @QueryProjection을 사용한다. 

> 내 생각에는 @QueryProjection을 사용하는 것이 꼭 나쁜 방법은 아니다. Projections.bean, Projections.fields, Projections.constructor를 사용할 경우에는 QueryDsl 쿼리의 select절 내에 Projections 관련 코드가 들어간다. 추후에 QueryDsl 라이브러리의 변경사항 등이 발생할 경우 SQL을 수행하는 비즈니스 로직을 일일이 찾아줘야 하는 심각한 문제가 발생할 수 있다.  
>
> 반면, @QueryProjection은 단순히 DTO에만 선언하는 방식이다. @QueryProjection을 사용하지 않는 기본 DTO를 만들고 이것을 상속받은 DTO클래스를 만들어 @QueryProjection 을 적용하면, 추후 @QueryProjection이 deprecated 되었을 경우 상속관계로 상속받는 다른 클래스를 이용하도록 풀어낼 수도 있다.  
>
> 굳이 이렇게 풀지 않더라도, Dto에 남겨놓는 방식이 나중에 파악하여 일일이 고치기도 수월할 뿐 아니라, Entity나 Repository 계층에 간섭을 덜 해도 된다는 점이 장점인 것 같다.

잡담이 길었다. 이번 예제에서 사용할 DTO 는 Member + Team을 DTO 계층으로 표현하려 하는 MemberTeamDto 라는 이름의 클래스이다.  

예) MemberTeamDto.java

```java
package com.study.qdsl.dto;

import com.querydsl.core.annotations.QueryProjection;
import lombok.Data;

/**
 * @Data 는 Getter, Setter, NoArgsConstructor, toString, equals 등의 다양한 메서드를 생성해주는 역할
 */
@Data
public class MemberTeamDto {

	private Long memberId;
	private String username;
	private int age;
	private Long teamId;
	private String teamName;

	@QueryProjection
	public MemberTeamDto(Long memberId, String username, int age, Long teamId, String teamName){
		this.memberId = memberId;
		this.username = username;
		this.age = age;
		this.teamId = teamId;
		this.teamName = teamName;
	}
}

```



- 참고
  - @Data
    - Getter/Setter/ToString/NoArgsConstructor/EqualsAndHashCode 를 포함하는 롬복 어노테이션이다.
  - @QueryProjection
    - 프로젝션 할 생성자 위에 @QueryProjection 을 선언한다.
    - 매개변수로 DTO에서 사용할 필드들을 나열하고, 초기화 코드를 작성한다.

이렇게 

- DTO 작성
- @QueryProjection 로직 작성

을 마친 후에는 꼭 Gradle > compileQuerydsl 을 해주고 QMemberTeamDto가 생성되었는지를 확인하자.



# SearchCondition DTO 생성

검색 조건을 위한 DTO인 MemberSearchCondition 클래스 파일을 생성하자.

**예) MemberSearchCondition.java**

```java
package com.study.qdsl.dto.condition;

import lombok.Data;

@Data
public class MemberSearchCondition {
	private String username;
	private String teamName;
	private Integer ageGoe;
	private Integer ageLoe;
}
```



# Builder 사용방식

설명은 내일 정리하자 ㅠㅜ.....

**예) MemberJpaQdslRepository**

```java
@Repository
public class MemberJpaQdslRepository{
  private final EntityManager em;
  private final JPAQueryFactory queryFactory;
  
  public MemberJpaQdslRepository(EntityManager em){
    this.em = em;
    this.queryFactory = new JPAQueryFactory(em);
  }
  
  // ... 
  public List<MemberTeamDto> searchByBuilder(MemberSearchCondition condition){
    BooleanBuilder builder = new BooleanBuilder();

		/**
		 * 웹에서 넘어오는 파라미터 들은 null 로 넘어올 때도 있고 ""으로 넘어올 때도 있다.
		 * 이런 경우에 대해 편리함을 제공해주는 라이브러리가 SpringFramework 에서 제공해주는 StringUtils::hasText() 이다.
		 **/
    
		if (StringUtils.hasText(condition.getUsername())) {
			builder.and(member.username.eq(condition.getUsername()));
		}
		if (StringUtils.hasText(condition.getTeamName())) {
			builder.and(member.team.name.eq(condition.getTeamName()));
		}
		if(condition.getAgeGoe() != null){
			builder.and(member.age.goe(condition.getAgeGoe()));
		}
		if(condition.getAgeLoe() != null){
			builder.and(member.age.loe(condition.getAgeLoe()));
		}

		return queryFactory
			.select(new QMemberTeamDto(
						member.id.as("memberId"),
						member.username,
						member.age,
						member.team.id.as("teamId"),
						member.team.name.as("teamName")
					))
					.from(member)
					.where(builder)
					.leftJoin(member.team, team)
					.fetch();
	}
}
```



# Where절 동적쿼리

Where 절을 사용할 때에는 BooleanExpression을 코드를 작성하는데, 각 비교구문을 메소드로 분리할 수 있게 되어 코드가 더 깔끔해진다. 이것도 내일 저녁 중으로 정리!! ㅠㅜ